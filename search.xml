<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux笔记</title>
      <link href="/2020/07/15/Linux%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/15/Linux%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="B站搜索狂神说"><a href="#B站搜索狂神说" class="headerlink" title="B站搜索狂神说"></a>B站搜索狂神说</h1><h1 id="入门概述"><a href="#入门概述" class="headerlink" title="入门概述"></a>入门概述</h1><h3 id="我们为什么要学习Linux"><a href="#我们为什么要学习Linux" class="headerlink" title="我们为什么要学习Linux"></a>我们为什么要学习Linux</h3><p>linux诞生了这么多年，以前还喊着如何能取代windows系统，现在这个口号已经小多了，任何事物发展 都有其局限性都有其天花板。就如同在国内再搞一个社交软件取代腾讯一样，想想而已基本不可能，因 为用户已经习惯于使用微信交流，不是说技术上实现不了解而是老百姓已经习惯了，想让他们不用，即 使他们自己不用亲戚朋友还是要用，没有办法的事情。 用习惯了windows操作系统，再让大家切换到别的操作系统基本上是不可能的事情，改变一个人已经养 成的习惯太难。没有办法深入到普通老百姓的生活中，并不意味着linux就没有用武之地了。在服务器 端，在开发领域linux倒是越来越受欢迎，很多程序员都觉得不懂点linux都觉得不好意思，linux在开源 社区的地位依然岿然不动。 尤其是作为一个后端程序员，是必须要掌握Linux的，因为这都成为了你找工作的基础门槛了，所以不得 不学习！</p><h3 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h3><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而 编写的。 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><h1 id="走进Linux系统"><a href="#走进Linux系统" class="headerlink" title="走进Linux系统"></a>走进Linux系统</h1><h3 id="开机登录"><a href="#开机登录" class="headerlink" title="开机登录"></a>开机登录</h3><p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进 程”（daemon）。 开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中 会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示 的，输完回车即可！ 一般来说，用户的登录方式有三种： 命令行登录 ssh登录 图形界面登录 最高权限账户为 root，可以操作一切！</p><h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非 特殊情况下，不得已才会关机。 关机指令为：shutdown ；</p><pre class=" language-shell"><code class="language-shell">sync # 将数据由内存同步到硬盘中。shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机shutdown –h now # 立马关机shutdown –h 20:25 # 系统会在今天20:25关机shutdown –h +10 # 十分钟后关机shutdown –r now # 系统立马重启shutdown –r +10 # 系统十分钟后重启reboot # 就是重启，等同于 shutdown –r nowhalt # 关闭系统，等同于shutdown –h now 和 poweroff</code></pre><p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。</p><h3 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h3><p>1.一切皆文件</p><p>2.根目录/,所有的文件都挂载这个节点下</p><p>登录系统后,在当前命令窗口下输入命令:</p><blockquote><p>ls</p></blockquote><p>你会看到入下图所示</p><p><img src="Linux%E5%9B%BE%E7%89%87%5C1.png" alt=""></p><p><strong>以下是对这些目录的解释：</strong></p><ul><li>/bin： bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li>/boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。（不 要动）</li><li>/dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问 文件的方式是相同的。</li><li>/etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账 号命名的。</li><li>/lib： 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。 （不要动）</li><li>/lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（存放 突然关机的一些文件）</li><li>/media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备 挂载到这个目录下。</li><li>/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上， 然后进入该目录就可以查看光驱里的内容了。（我们后面会把一些本地文件挂载在这个目录下）</li><li>/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个 目录下。默认是空的。</li><li>/proc： 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获 取系统信息。（不用管）</li><li>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序</li><li>/srv：该目录存放一些服务启动之后需要提取的数据。</li><li>/sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li><li>/tmp：这个目录是用来存放一些临时文件的。用完即丢的文件，可以放在这个目录下，安装包！</li><li>/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows 下的program files目录。</li><li>/usr/bin： 系统用户使用的应用程序。</li><li>/usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。Super</li><li>/usr/src： 内核源代码默认的放置目录。</li><li>/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录 下。包括各种日志文件。</li><li>/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被 删掉或清除。</li><li>/www：存放服务器网站相关的资源，环境，网站的项目</li></ul><h3 id="常用的基本命令"><a href="#常用的基本命令" class="headerlink" title="常用的基本命令"></a>常用的基本命令</h3><h4 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h4><blockquote><p>绝对路径、相对路径</p></blockquote><p>绝对路径路径的全称：C:\ProgramData\360safe\xxx.xx </p><p>比如说 360safe 目录下，那这个 xxx.xx 文件，对应我们的相对配置就 /xxx.xx </p><p>cd ： 切换目录命令！</p><p> ./ ： 当前目录</p><p> cd .. ： 返回上一级目录</p><blockquote><p>ls (列出目录!)</p></blockquote><p>在Linux中 ls 可能是最常常被使用的 ! </p><p>-a参数：all ，查看全部的文件，包括隐藏文件</p><p> -l 参数 列出所有的文件，包含文件的属性和权限，没有隐藏文件</p><p> 所有Linux可以组合使用！</p><blockquote><p>cd 命令 切换目录</p></blockquote><blockquote><p>pwd显示当前用户所在的目录</p></blockquote><blockquote><p>mkdir 创建目录 mkdir -p 创建一个层级目录  目录=文件夹</p></blockquote><blockquote><p>rmdir 删除目录 rmdir -p 删除一个层级目录</p></blockquote><blockquote><p>cp 复制文件或者目录</p></blockquote><blockquote><p>rm 移除文件或者目录</p></blockquote><p>-f 忽略不存在的文件，不会出现警告，强制删除</p><p>！ -r 递归删除目录！</p><p> -i 互动，删除询问是否删除</p><blockquote><p>rm -rf / 系统所有的文件就被删除了，删库跑路就是这么操作的</p></blockquote><blockquote><p>mv 移动文件或者目录 重命名</p></blockquote><p>f 强制</p><p> -u 只替换已经更新过的文件</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><h3 id="十个字母-1类型"><a href="#十个字母-1类型" class="headerlink" title="十个字母; 1类型"></a><strong>十个字母; 1类型</strong></h3><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安 全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用 ll 或者 ls –l 命令来显示一个文件的属性以及文件所属的用户和组，</p><p><img src="Linux%E5%9B%BE%E7%89%87%5C2.png" alt="2"></p><blockquote><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p><p>​            当为[d]则是目录</p><p>​            当为[-]则是文件;</p><p>​            当为[I]则表示为链接文档</p></blockquote><p>文件的3个权限</p><p>读            写        执行</p><p>r               w         x</p><p>4              2          1</p><p>其中：</p><p> 第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p><p> 第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限</p><p>； 第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权 限。</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="修改文件属性"><a href="#修改文件属性" class="headerlink" title="修改文件属性"></a>修改文件属性</h3><blockquote><p>chgrp : 更改文件属组</p><p>chgrp [-R] 属组名 文件名</p></blockquote><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有 文件的属组都会更改。</p><blockquote><p>chown：更改文件属主，也可以同时更改文件属组</p><p>chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名</p></blockquote><blockquote><p>chmod：更改文件9个属性（必须要掌握）</p><p>chmod [-R] xyz 文件或目录</p></blockquote><h3 id="文件内容查"><a href="#文件内容查" class="headerlink" title="文件内容查"></a>文件内容查</h3><p>我们会经常使用到文件查看！</p><p> Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容，用来读文章，或者读取配置文件啊，都使用cat名</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl 显示的时候，顺道输出行号！ 看代码的时候，希望显示行号！ 常用</li><li>more 一页一页的显示文件内容，带余下内容的（空格代表翻页，enter 代表向下看一行， :f 行 号）</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ （空格下翻页，pageDown， pageUp键代表翻动页面！退出 q 命令，查找字符串 /要查询的字符向下查询，向上查询使用？要 查询的字符串，n 继续搜寻下一个，N 上寻找！）</li><li>head 只看头几行 通过 -n 参数来控制显示几行！</li><li>tail   只看尾巴几行 -n 参数 要查看几行！</li></ul><h2 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h2><h3 id="什么是Vim编辑器"><a href="#什么是Vim编辑器" class="headerlink" title="什么是Vim编辑器"></a>什么是Vim编辑器</h3><p>vim 通过一些插件可以实现和IDE一样的功能！ Vim是从 vi 发展出来的一个文本编辑器。</p><p>代码补完、编译及错误跳转等方便编程的功能特别丰富，在程 序员中被广泛使用。</p><p>尤其是Linux中，必须要会使用Vim（查看内容，编辑内容，保存内容！） 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。</p><p> vim 则可以说是程序开发者的一项很好用的工具。 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p><p> 连 vim 的官方网站 (<a href="http://www.vim.org" target="_blank" rel="noopener">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件</p><h3 id="三种使用模式"><a href="#三种使用模式" class="headerlink" title="三种使用模式"></a>三种使用模式</h3><p>基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和 底线命令模式（Last line mode）。</p><blockquote><p>Vim 【文件】  进去编写文件页面</p></blockquote><ul><li><p>i 切换到输入模式，以输入字符。</p></li><li><p>x 删除当前光标所在处的字符。</p></li><li><p>: 切换到底线命令模式，以在最底一行输入命令。 如果是编辑模式，需要先退出编辑模式！ESC</p></li><li><p>q 退出程序</p></li><li><p>w 保存文件</p></li></ul><blockquote><p>完整的演示说明</p></blockquote><p>新建或者编辑文件，按 i 进入编辑模式，编写内容，编写完成后退出编辑模式，esc，退出之后进入底线 命令模式 ： wq 保存退出</p><h3 id="Vim按键说明"><a href="#Vim按键说明" class="headerlink" title="Vim按键说明"></a>Vim按键说明</h3><blockquote><p>1.数字 &lt; space&gt; 那个 n 表示『数字』，例如 20 。快捷切换光标， 数字 + 空格</p><p>2.数字&lt; Enter&gt; n 为数字。光标向下移动 n 行(常用)</p><p>3./word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串， 就输入 /vbird 即可！(常用)</p><p>4.n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird         这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字 符串。如果是执行 ?vbird 的话，那        么    按下 n 则会向上继续搜寻名称为 vbird 的字符串！</p><p>5.N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示       『向上』搜寻 vbird 。</p><p>6.u 复原前一个动作。(常用)</p><p>7.i, I 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在 行的第一个非空格符处开始输入』。(常用)</p><p>8.[Esc] 退出编辑模式，回到一般模式中(常用</p><p>9.:wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用)</p><p>10.:set nu 设置行号，代码中经常 会使用！ 显示行号，设定之后，会在每一行的前缀显示该行的行号</p></blockquote><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><p>你一般在公司中，用的应该都不是 root 账户！</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管 理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另 一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录</p><p>实现用户账号的管理，要完成的工作主要有如下几个方面:</p><ul><li><p>用户账号的添加、删除与修改。</p></li><li><p>用户口令的管理。</p></li><li><p>用户组的管理</p></li></ul><blockquote><p>用户账号的管理</p></blockquote><p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等 资源。 属主，属组</p><h3 id="useradd-命令-添加用户"><a href="#useradd-命令-添加用户" class="headerlink" title="useradd 命令 添加用户"></a>useradd 命令 添加用户</h3><p>useradd -选项 用户名 </p><p>-m： 自动创建这个用户的主目录 /home/qinjiang</p><p> -G : 给用户分配组！</p><h3 id="userdel-删除用户"><a href="#userdel-删除用户" class="headerlink" title="userdel 删除用户"></a>userdel 删除用户</h3><p>userdel -r 删除用户的时候将他的目录页一并删掉!</p><h3 id="usermod-修改用户"><a href="#usermod-修改用户" class="headerlink" title="usermod 修改用户"></a>usermod 修改用户</h3><p>usermod -d 修改用户usermod 对应修改的内容 修改那个用户</p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="切换用户的命令为-su-用户名"><a href="#切换用户的命令为-su-用户名" class="headerlink" title="切换用户的命令为: su 用户名"></a>切换用户的命令为: su 用户名</h3><p>1.从普通用户切换到root用户，还可以使用命令：sudo su</p><p>2.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令</p><p>3.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例 如：【su - root】</p><p> $表示普通用户</p><p> #表示超级用户，也就是root用户</p><p> 有的小伙伴在阿里云买完服务器后，主机名是一个随机字符串！</p><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="用户的密码设置问题"><a href="#用户的密码设置问题" class="headerlink" title="用户的密码设置问题!"></a>用户的密码设置问题!</h3><p>我们一般通过root创建用户的时候！要配置密码！</p><p> Linux上输入密码是不会显示的，你正常输入就可以了，并不是系统的问题！ 在公司中，你们一般拿不到公司服务器的 root 权限，都是一些分配的账号！</p><p> 如果是超级用户的话：</p><pre class=" language-shell"><code class="language-shell">passwd username：new password：re password：</code></pre><p>如果是普通用户的话:</p><pre class=" language-shell"><code class="language-shell">passwd(current) UNIX password:new password： # 密码不能太过于简单！re password：</code></pre><blockquote><p>锁定账户</p></blockquote><p>root，比如张三辞职了！冻结这个账号，一旦冻结，这个人就登录不上系统了！</p><pre class=" language-shell"><code class="language-shell">passwd -l qinjiang # 锁定之后这个用户就不能登录了！passwd -d qinjiang # 没有密码也不能登录！</code></pre><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p>属主、属组</p><p> 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理（开发、测试、运维、 root）。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户 组在创建用户时同时创建。 </p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的 更新。</p><blockquote><p>创建一个用户组 groupadd</p><p>创建完查看文件 cat /etc/group</p></blockquote><p>创建完用户组后可以得到一个组的id，这个id是可以指定的！ -g 520 ， 若果不指定就是自增1</p><blockquote><p>删除一个用户组groupdel</p></blockquote><blockquote><p>修改用户组的权限信息和名字 groupmod -g -n</p></blockquote><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><blockquote><p>df(列出文件系统整体的磁盘使用量)     du(检查磁盘空间使用量!)</p></blockquote><p>df -h 更详细的展示</p><p>du -a</p><p>du -sm/* 检查根目录下每个目录所占中的容量</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>Linux中一切皆文件 </p><p>（文件：读写执行（查看，创建，删除，移动，复制，编辑），权限（用户、用户组）。系统：（磁 盘，进程））</p><p> 对于我们开发人员来说，其实Linux更多偏向于使用即可！</p><blockquote><p>基本概念</p></blockquote><p>1、在Linux中，每一个程序都是有自己的一个进程，每一个进程都有一个id号！</p><p> 2、每一个进程呢，都会有一个父进程！</p><p> 3、进程可以有两种存在方式：前台！后台运行！</p><p> 4、一般的话服务都是后台运行的，基本的程序都是前台运行的！</p><blockquote><p>命令</p></blockquote><p>ps 查看当前系统正在执行的各种进程信息!</p><p>ps:</p><ul><li><p>-a 显示当前终端运行的所有的进程信息（当前的进程一个）</p></li><li><p>-u 以用户的信息显示进程</p></li><li><p>-x 显示后台运行进程的参数！</p></li></ul><pre class=" language-shell"><code class="language-shell"># ps -aux 查看所有的进程ps -aux|grep mysql# | 在Linux这个叫做管道符 A|B# grep 查找文件中符合条件的字符串！</code></pre><p>对于我们来说，这里目前只需要记住一个命令即可 ps -xx|grep 进程名字！ 过滤进程信息！</p><p> <strong>ps -ef：可以查看到父进程的信息</strong></p><pre class=" language-shell"><code class="language-shell">ps -ef|grep mysql # 看父进程我们一般可以通过目录树结构来查看！# 进程树！pstree -pu-p 显示父id-u 显示用户组</code></pre><p>结束进程: 杀掉进程，等价于window结束任务!</p><blockquote><p>kill -9 进程id</p></blockquote><p>表示强制结束该进程!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记</title>
      <link href="/2020/07/14/Docker%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/14/Docker%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Docker前面笔记"><a href="#Docker前面笔记" class="headerlink" title="Docker前面笔记"></a>Docker<a href="https://blog.csdn.net/weixin_43831049/article/details/106184345" target="_blank" rel="noopener">前面笔记</a></h2><h2 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h2><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200705175117085.png" alt="image-20200705175117085"></p><pre class=" language-shell"><code class="language-shell">#开启父容器[root@lele home]# docker run -it --name docker01 test/centos:1.0#开启子容器#--volumes-from 相当于继承的意思#父容器必须有挂载的容器卷 ，子容器才能--volumes-from继承父容器，达到数据共享，共享的地方也只能是容器卷里面的内容。[root@lele home]# docker run -it --name docker02 --volumes-from docker01 test/centos:01</code></pre><blockquote><p>测试</p></blockquote><p><img src="docker%E5%9B%BE%E7%89%87/1.png" alt=""></p><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200705175700634.png" alt="image-20200705175700634"></p><p>结论：</p><p>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。</p><p>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！</p><h2 id="DockerFile的指令"><a href="#DockerFile的指令" class="headerlink" title="DockerFile的指令"></a>DockerFile的指令</h2><pre class=" language-shell"><code class="language-shell">FROM                # 基础镜像，一切从这里开始构建MAINTAINER             # 镜像是谁写的， 姓名+邮箱RUN                    # 镜像构建的时候需要运行的命令ADD                    # 步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录WORKDIR                # 镜像的工作目录VOLUME                # 挂载的目录EXPOSE                # 保留端口配置CMD                    # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。ENTRYPOINT            # 指定这个容器启动的时候要运行的命令，可以追加命令ONBUILD                # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。COPY                # 类似ADD，将我们文件拷贝到镜像中ENV                    # 构建的时候设置环境变量！</code></pre><h2 id="Docker网络详解"><a href="#Docker网络详解" class="headerlink" title="Docker网络详解"></a>Docker网络详解</h2><h3 id="理解Docker0"><a href="#理解Docker0" class="headerlink" title="理解Docker0"></a>理解Docker0</h3><pre class=" language-java"><code class="language-java">测试</code></pre><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704171143856.png" alt="image-20200704171143856"></p><p>三个网络</p><pre class=" language-shell"><code class="language-shell"># 问题： docker 是如何处理容器网络访问的？</code></pre><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704171851548.png" alt="image-20200704171851548"></p><pre class=" language-shell"><code class="language-shell">#[root@lele LeLe]# docker run -d -P --name tomcat01 tomcat#查看容器的内部网络地址 ip addr 发现容器启动的时候会得到一个 eth0@if159 ip地址，docker分配的[root@lele LeLe]# docker exec -it tomcat01 ip addr1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever158: eth0@if159: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever#思考 linux 能不能ping 通容器内部[root@lele LeLe]# ping 172.17.0.2PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.092 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.065 ms#linux 可以ping通 docker 容器内部</code></pre><blockquote><p>原理</p></blockquote><p>1.我们没启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0桥接模式，使用的技术是evth-pair技术!</p><p>再次测试ip addr</p><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704173415610.png" alt="image-20200704173415610"></p><p>2.在启动一个容器测试，发现了又多了一对网卡</p><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704173543147.png" alt="image-20200704173543147"></p><pre class=" language-shell"><code class="language-shell"># 我们发现这个容器带来网卡，都是一对对的# evth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连# 正因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备的# OpenStac，Docker容器之间的连接，ovs的连接，都是使用 evth-pair 技术</code></pre><p>3.我们来测试下tomcat01和tomcat02是否可以ping通</p><pre class=" language-shell"><code class="language-shell">[root@lele LeLe]# docker exec -it tomcat02 ping 172.17.0.2PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.109 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.082 ms#结论: 容器和容器之间是可以互相ping通的</code></pre><p>绘制一个网络模型图：</p><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704175225662.png" alt="image-20200704175225662"></p><p>结论：tomcat01 和tomcat02 是公用的一个路由器，docker0。</p><p>所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip</p><blockquote><p>小结</p></blockquote><p>Docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥，docker0</p><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704180112884.png" alt="image-20200704180112884"></p><p>Docker中的所有的网络接口都是虚拟的，虚拟的转发效率高!(内网传递文件!)</p><p>只要容器删除，对应网桥一对就没了!</p><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704182137254.png" alt="image-20200704182137254"></p><h3 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h3><blockquote><p>思考一个场景，我们编写了一个微服务，database url=ip:, 项目不重启，数据库ip换掉了，我们希望可以处理这个问题，可以用名字来进行访问容器?</p></blockquote><pre class=" language-shell"><code class="language-shell"># 如何解决呢?[root@lele LeLe]# docker exec -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known# 通过--link 既可以解决了网络连通问题[root@lele LeLe]# docker run -d -P --name tomcat03 --link tomcat02 tomcat7be48de46252de2c1b79bf13e156ef393fbb4d159f9c636cf84c5b7a977f3f4f[root@lele LeLe]# docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.17.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.130 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.063 ms</code></pre><p>探究：inspect</p><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704182548237.png" alt="image-20200704182548237"></p><p>其实这个tomcat03 就是在本地配置了tomcat02的配置</p><pre class=" language-shell"><code class="language-shell">#查看hosts 配置，在这里原理发现root@7be48de46252:/usr/local/tomcat# cat /etc/hosts127.0.0.1    localhost::1    localhost ip6-localhost ip6-loopbackfe00::0    ip6-localnetff00::0    ip6-mcastprefixff02::1    ip6-allnodesff02::2    ip6-allrouters172.17.0.3    tomcat02 10cdd2aad84e172.17.0.4    7be48de46252</code></pre><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704183808651.png" alt="image-20200704183808651"></p><p>本质探究：–link就是我们在hosts配置中增加了一个 tomcat02 通过名字也可以ping通  ，10cdd2aad84e像这种就是通过ip来ping</p><p>我们现在玩Docker 已经不建议使用 –link了!</p><p>自定义网络!不适合docker0!</p><p>docker0问题：他不支持容器名连接访问!</p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><blockquote><p>查看所有的docker网络</p></blockquote><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704192407432.png" alt="image-20200704192407432"></p><p><strong>网络模式</strong></p><p>bridge : 桥接 docker(默认，自己创建也使用bridge 模式)</p><p>none : 不配置网络</p><p>host : 和数组及共享网络</p><p>container : 容器网络连通!(用得少!局限很大)</p><p><strong>测试</strong></p><pre class=" language-shell"><code class="language-shell"># 我们直接启动命令 --net bridge，而这个就是我们的docker0docker run -d -P --name tomcat01 --net bridge tomcat# docker0 特点: 默认，域名不能访问 --link可以打通连接# --driver bridge 桥接# --subnet 子网地址# --gateway 网关地址#我们可以自定一个网络[root@lele /]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynetb58986a8e319c4be83e9c3ce37c3eb947d94972fd652bea34e87d2a7ed8b1b93[root@lele /]# docker network lsNETWORK ID          NAME                DRIVER              SCOPEc7567ec83458        bridge              bridge              localdf32f0ff36e8        host                host                localb58986a8e319        mynet               bridge              local4fb1b575c678        none                null                local</code></pre><p>我们自己的网络也就创建好了!</p><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200704194318271.png" alt="image-20200704194318271"></p><pre class=" language-shell"><code class="language-shell">[root@lele /]# docker run -d -P --name tomcat-net-01 --net mynet tomcatcad3b4f2bb639fa621b09a883c83fdcdcd8b17c52cc7210cb0497184aac26ec0[root@lele /]# docker run -d -P --name tomcat-net-02 --net mynet tomcat8c21b36fb33786f19d29dcefe0811eb5c54e45a251c0dc2594fea693cff53378[root@lele /]# docker network inspect mynet[    {        "Name": "mynet",        "Id": "b58986a8e319c4be83e9c3ce37c3eb947d94972fd652bea34e87d2a7ed8b1b93",        "Created": "2020-07-04T19:37:38.750077885+08:00",        "Scope": "local",        "Driver": "bridge",        "EnableIPv6": false,        "IPAM": {            "Driver": "default",            "Options": {},            "Config": [                {                    "Subnet": "192.168.0.0/16",                    "Gateway": "192.168.0.1"                }            ]        },        "Internal": false,        "Attachable": false,        "Ingress": false,        "ConfigFrom": {            "Network": ""        },        "ConfigOnly": false,        "Containers": {            "8c21b36fb33786f19d29dcefe0811eb5c54e45a251c0dc2594fea693cff53378": {                "Name": "tomcat-net-02",                "EndpointID": "fc3abefe24fb2de0add865249d409b4333fddf0b0bd0b630243624d19eaa2e34",                "MacAddress": "02:42:c0:a8:00:03",                "IPv4Address": "192.168.0.3/16",                "IPv6Address": ""            },            "cad3b4f2bb639fa621b09a883c83fdcdcd8b17c52cc7210cb0497184aac26ec0": {                "Name": "tomcat-net-01",                "EndpointID": "39849a96f23101c872ba63e94ceee9b8a90d5314128bfe033859c8a253c80057",                "MacAddress": "02:42:c0:a8:00:02",                "IPv4Address": "192.168.0.2/16",                "IPv6Address": ""            }        },        "Options": {},        "Labels": {}    }]# 再次测试ping链接[root@lele /]# docker exec -it tomcat-net-01 ping 192.168.0.3PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.136 ms64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.093 ms64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.083 ms^C--- 192.168.0.3 ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2msrtt min/avg/max/mdev = 0.083/0.104/0.136/0.023 ms# 现在不使用 --link 也可以ping名字了[root@lele /]# docker exec -it tomcat-net-01 ping tomcat-net-02PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.064 ms64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.089 ms^C--- tomcat-net-02 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1msrtt min/avg/max/mdev = 0.064/0.076/0.089/0.015 ms</code></pre><p>我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络!</p><p>好处:</p><p>redis- 不同的集群使用不同的网络，保证集群是安全和健康的</p><p>mysql-不同的集群使用不同的网络，保证集群是安全和健康的</p><h3 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h3><blockquote><p>绘图理解</p></blockquote><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200705110350552.png" alt="image-20200705110350552"></p><blockquote><p>Connect a container to a net work 连接一个容器到网络</p></blockquote><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200705104505822.png" alt="image-20200705104505822"></p><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200705104527736.png" alt="image-20200705104527736"></p><pre class=" language-shell"><code class="language-shell"># mynet 自定定义的网络# tomcat01 docker0里面的容器# 把Docker0里面的tomcat01容器 连接到mynet网络里面，这样tomcat01就可ping mynet里面的地址了。[root@lele home]# docker network connect mynet tomcat01# 测试打通 tomcat01 -mynet# 连通之后就是将 tomcat01 放到了 mynet网络下# 一个容器两个ip地址#阿里云服务: 公网ip 私网ip</code></pre><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200705105429106.png" alt="image-20200705105429106"></p><pre class=" language-shell"><code class="language-shell">#因为设置了通过容器连接网络，所以01是连通的[root@lele ~]# docker exec -it tomcat01 ping 192.168.0.2PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=0.126 ms64 bytes from 192.168.0.2: icmp_seq=2 ttl=64 time=0.100 ms#反之，02没有设置，所有连接不通[root@lele ~]# docker exec -it tomcat02 ping 192.168.0.2Error: No such container: tomcat02</code></pre><p>结论: 假设要跨网络操作别人，就需要使用docker network connect 连通!</p><h3 id="实战-部署Redis集群"><a href="#实战-部署Redis集群" class="headerlink" title="实战:部署Redis集群"></a>实战:部署Redis集群</h3><blockquote><p>三主三从，加入主机r-m3停掉了，从机就需要顶替上去</p></blockquote><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200705110810240.png" alt="image-20200705110810240"></p><p>​        shell脚本</p><pre class=" language-shell"><code class="language-shell">#创建网卡docker network create redis --subnet 172.38.0.0/16#通过脚本创建六个redis配置for port in $(seq 1 6); \do \mkdir -p /home/redis-cluster/redis-${port}/conftouch /home/redis-cluster/redis-${port}/conf/redis.confcat << EOF >>/home/redis-cluster/redis-${port}/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1${port}cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdone# 开启集群docker run -p 6371:6379 -p 16371:16379 --name redis-1 \-v /home/redis-cluster/redis-1/data:/data \-v /home/redis-cluster/redis-1/conf/redis.conf:/etc/redis/redis.conf \-d --net redis --ip 172.38.0.11 redis:5.0.8-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6376:6379 -p 16376:16379 --name redis-6 \-v /home/redis-cluster/redis-6/data:/data \-v /home/redis-cluster/redis-6/conf/redis.conf:/etc/redis/redis.conf \-d --net redis --ip 172.38.0.16 redis:5.0.8-alpine3.11 redis-server /etc/redis/redis.conf# 进入redis-1的容器[root@lele redis-cluster]# docker exec -it redis-1 /bin/sh# 创建集群配置/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1>>> Performing hash slots allocation on 6 nodes...Master[0] -> Slots 0 - 5460Master[1] -> Slots 5461 - 10922Master[2] -> Slots 10923 - 16383Adding replica 172.38.0.15:6379 to 172.38.0.11:6379Adding replica 172.38.0.16:6379 to 172.38.0.12:6379Adding replica 172.38.0.14:6379 to 172.38.0.13:6379M: da32ed29f8046d767427f2fb57937e6a6f8fadec 172.38.0.11:6379   slots:[0-5460] (5461 slots) masterM: 825fb8d6b06068f62745e01c797d83e836f91feb 172.38.0.12:6379   slots:[5461-10922] (5462 slots) masterM: dfe2d4e5e7b6abc005b13a66ccdc12b5954b27c5 172.38.0.13:6379   slots:[10923-16383] (5461 slots) masterS: 4620497aa894cf2fe55a9d5211a09dfc43fb01a9 172.38.0.14:6379   replicates dfe2d4e5e7b6abc005b13a66ccdc12b5954b27c5S: 73722e254fe02d6aa0ded4175d09ef91a7d697c0 172.38.0.15:6379   replicates da32ed29f8046d767427f2fb57937e6a6f8fadecS: bfd97c50b9cc404d34ed4f55a21259fa66f6a7d3 172.38.0.16:6379   replicates 825fb8d6b06068f62745e01c797d83e836f91febCan I set the above configuration? (type 'yes' to accept): yes>>> Nodes configuration updated>>> Assign a different config epoch to each node>>> Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join...>>> Performing Cluster Check (using node 172.38.0.11:6379)M: da32ed29f8046d767427f2fb57937e6a6f8fadec 172.38.0.11:6379   slots:[0-5460] (5461 slots) master   1 additional replica(s)S: bfd97c50b9cc404d34ed4f55a21259fa66f6a7d3 172.38.0.16:6379   slots: (0 slots) slave   replicates 825fb8d6b06068f62745e01c797d83e836f91febM: dfe2d4e5e7b6abc005b13a66ccdc12b5954b27c5 172.38.0.13:6379   slots:[10923-16383] (5461 slots) master   1 additional replica(s)S: 73722e254fe02d6aa0ded4175d09ef91a7d697c0 172.38.0.15:6379   slots: (0 slots) slave   replicates da32ed29f8046d767427f2fb57937e6a6f8fadecM: 825fb8d6b06068f62745e01c797d83e836f91feb 172.38.0.12:6379   slots:[5461-10922] (5462 slots) master   1 additional replica(s)S: 4620497aa894cf2fe55a9d5211a09dfc43fb01a9 172.38.0.14:6379   slots: (0 slots) slave   replicates dfe2d4e5e7b6abc005b13a66ccdc12b5954b27c5[OK] All nodes agree about slots configuration.>>> Check for open slots...>>> Check slots coverage...[OK] All 16384 slots covered.</code></pre><p>docker搭建redis集群完成</p><blockquote><p>主机停掉，从机自动配置上去代替主机。</p></blockquote><p><img src="C:%5CUsers%5C22529%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200705114455785.png" alt="image-20200705114455785"></p><p>我们使用了docker之后，所有的技术都会慢慢的变得简单起来。</p><h3 id="SpringBoot微服务打包Docker镜像"><a href="#SpringBoot微服务打包Docker镜像" class="headerlink" title="SpringBoot微服务打包Docker镜像"></a>SpringBoot微服务打包Docker镜像</h3><p>1.构建springboot项目</p><p>2.打包应用</p><p>3.编写dockerfile</p><p>4.构建镜像</p><p>5.发布运行</p><p>以后我们使用了Docker之后，给别人交付的就是一个镜像即可。</p><p>docker构建镜像一键部署项目</p><p>预告：如果有很多镜像，？？100个镜像？</p><p>企业级别开发就需要用到下面技术</p><p>未完待续….</p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><h3 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h3><h3 id="CI-CD之Jenkins"><a href="#CI-CD之Jenkins" class="headerlink" title="CI/CD之Jenkins"></a>CI/CD之Jenkins</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
